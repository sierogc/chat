<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Due Chat Randomiche Bilanciate e Responsive</title>
    
    <style>
        /* Impostazioni globali */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased; 
            text-rendering: optimizeLegibility;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #ffffff; 
            display: flex;
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            width: 100vw; 
            overflow-x: auto; 
        }

        /* Contenitore Principale per le Due Chat (Desktop/Affiancate) */
        #main-container {
            display: flex;
            gap: 40px; 
            padding: 20px;
            height: 100vh; 
            width: 100%; 
            align-items: center;
            justify-content: center; 
            box-sizing: border-box;
        }

        /* Lo schermo centrato (responsive) */
        .chat-container {
            flex: 1; 
            width: 100%; 
            height: 100%; 
            
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            border: none; 
            box-shadow: none;
        }
        
        /* Finestra dove appaiono i messaggi (Scorrimento Manuale) */
        .chat-window {
            flex-grow: 1; 
            padding: 20px 10px;
            overflow-y: auto; /* SCROLL MANUALE */
            display: flex;
            flex-direction: column;
            gap: 10px; 
            -webkit-overflow-scrolling: touch; 
        }

        /* Stile generico per una bolla di messaggio */
        .message {
            padding: 12px 18px;
            line-height: 1.4;
            max-width: 75%;
            word-wrap: break-word;
            opacity: 0;
            transform: scale(0.9);
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            position: relative; 
        }

        /* Forme delle bolle iMessage (Destinatario) */
        .message.recipient {
            align-self: flex-start;
            background-color: #e5e5ea;
            color: #000000;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
            border-bottom-left-radius: 4px; 
        }

        /* Forme delle bolle iMessage (Mittente) */
        .message.sender {
            align-self: flex-end;
            background-color: #007aff;
            color: #ffffff;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-left-radius: 18px;
            border-bottom-right-radius: 4px; 
        }


        /* Indicatore "Sta scrivendo..." */
        .typing-indicator {
            display: none; 
            align-self: flex-start;
            background-color: #e5e5ea;
            color: #000000;
            
            padding: 12px 18px 12px 18px; 
            
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
            border-bottom-left-radius: 4px; 
            
            width: auto; 
            height: auto; 
            
            display: flex; 
            align-items: center;
            justify-content: center; 
            box-sizing: content-box; 
            position: relative;
        }

        /* Animazione puntini iOS */
        @keyframes ios-dot-fade {
            0%, 80%, 100% { opacity: 0.3; } 
            40% { opacity: 1; } 
        }

        .dots span {
            display: inline-block;
            width: 10px; 
            height: 10px; 
            background-color: #b0b0b0; 
            border-radius: 50%;
            margin: 0 3px; 
            animation: ios-dot-fade 1.5s infinite ease-in-out; 
        }

        .dots span:nth-child(1) { animation-delay: 0s; }
        .dots span:nth-child(2) { animation-delay: 0.2s; } 
        .dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes pop-in {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Barra di input finta */
        .fake-input-bar {
            padding: 10px 15px;
            border-top: none; 
            background-color: #ffffff; 
            padding-bottom: 25px; 
        }

        /* Contenitore della barra di testo */
        .fake-input-box {
            border: none;
            background-color: #f0f2f5; 
            border-radius: 20px;
            height: 40px;
            display: flex;
            align-items: center;
            padding-left: 15px;
            font-size: 1rem;
            position: relative; 
            overflow: hidden; 
        }

        /* Elemento testuale normale "Messaggio" */
        .input-typing-text {
            color: #8e8e93; 
            display: block;
            white-space: nowrap; 
        }

        /* Testo digitato dal Mittente (Contenitore + Cursore) */
        .input-message-typing-container {
            display: none;
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            padding-right: 2px; 
        }
        
        .input-message-typing {
            color: #000000; 
            white-space: nowrap;
            overflow: hidden;
            font-size: 1rem;
        }

        /* Animazione Cursore */
        .caret {
            width: 2px;
            height: 70%;
            background-color: #007aff; 
            margin-left: 1px;
            animation: blink-caret 0.8s infinite;
        }

        @keyframes blink-caret {
            from, to { opacity: 0; }
            50% { opacity: 1; }
        }

        /* RESPONSIVITÀ COMPLETA: Schermi stretti (es. Smartphone) */
        @media (max-width: 800px) {
            #main-container {
                /* Permette alle colonne di andare a capo */
                flex-direction: column; 
                
                /* Regola l'altezza e la spaziatura per la modalità verticale */
                height: 100vh;
                padding: 10px;
                gap: 20px;
                overflow-y: auto; /* Abilita lo scroll per l'intero blocco se necessario */
            }

            .chat-container {
                /* Fa sì che ogni chat occupi il 100% della larghezza */
                width: 100%;
                max-width: none;
                
                /* Forza le chat a occupare metà dell'altezza ciascuna, ottimale per lo smartphone */
                height: 50vh; 
            }
        }

    </style>
</head>
<body>

    <div id="main-container">
        <div id="chat-container-1" class="chat-container">
            <div id="chat-window-1" class="chat-window">
                <div id="typing-indicator-1" class="typing-indicator dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="fake-input-bar">
                <div class="fake-input-box">
                    <span id="input-typing-text-1" class="input-typing-text">Messaggio</span>
                    <div id="input-message-typing-container-1" class="input-message-typing-container">
                        <span id="input-message-typing-1" class="input-message-typing"></span>
                        <span class="caret"></span>
                    </div>
                </div>
            </div>
        </div>

        <div id="chat-container-2" class="chat-container">
            <div id="chat-window-2" class="chat-window">
                <div id="typing-indicator-2" class="typing-indicator dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="fake-input-bar">
                <div class="fake-input-box">
                    <span id="input-typing-text-2" class="input-typing-text">Messaggio</span>
                    <div id="input-message-typing-container-2" class="input-message-typing-container">
                        <span id="input-message-typing-2" class="input-message-typing"></span>
                        <span class="caret"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="typing-audio" loop>
        <source src="typing_sound.mp3" type="audio/mpeg">
    </audio>
    <audio id="receive-audio">
        <source src="message_received.mp3" type="audio/mpeg">
    </audio>


    <script>
        document.addEventListener("DOMContentLoaded", function() {

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const typingAudio = document.getElementById('typing-audio');
            const receiveAudio = document.getElementById('receive-audio');

            let chat1Finished = false;
            let chat2Finished = false;

            // Variabili per tracciare gli script precedenti e garantire l'unicità
            let previousScript1 = null;
            let previousScript2 = null;
            let chat1, chat2;

            // =================================================================
            // === MESSAGGI BASE E GENERAZIONE RANDOMICA ===
            // =================================================================

            const senderMessages = [
                'Ciao! Sì, scusa.',
                'Dimmi tutto.',
                'ASSOLUTAMENTE SÌ.',
                'Perfetto, ci sentiamo dopo.',
                'Non preoccuparti, arrivo in 5 minuti.',
                'A che ora ci vediamo stasera?',
                'OK, prenoto io il tavolo.',
                'Ci sto! Che ne dici di quella nuova pizzeria?'
            ];

            const fixedRecipientStart = 'Ehi, ci sei?';
            const recipientMessagesPool = [
                'Volevo solo sapere se ti andava di ordinare una pizza.',
                'Perfetto, sentiamoci verso le 19:30!',
                'Quando arrivi? Ti aspetto fuori.',
                'Hai già mangiato?',
                'Mi fai sapere il prima possibile, grazie.',
                'Sì, ho visto il messaggio, grazie.',
                'Assolutamente, ottima idea.'
            ];

            function shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            }

            // Funzione base per generare uno script bilanciato
            function generateRandomScript() {
                const shuffledSender = shuffleArray(senderMessages);
                const shuffledRecipientBody = shuffleArray(recipientMessagesPool);
                
                const script = [];
                let senderIndex = 0;
                let recipientIndex = 0;
                let senderCount = 0;
                let recipientCount = 0;

                // 1. Frase iniziale fissa del destinatario
                script.push({ type: 'typing', delay: Math.floor(Math.random() * 1000) + 500 });
                script.push({ type: 'message', sender: 'recipient', text: fixedRecipientStart, delay: Math.floor(Math.random() * 1500) + 1000 });
                recipientCount++; 

                // 2. Corpo della conversazione casuale bilanciata
                while (senderIndex < shuffledSender.length || recipientIndex < shuffledRecipientBody.length) {
                    
                    let nextIsRecipient;
                    
                    // Logica di bilanciamento per finire insieme
                    if (senderCount === recipientCount) {
                        nextIsRecipient = Math.random() < 0.5;
                    } else if (senderCount < recipientCount) {
                        nextIsRecipient = Math.random() < 0.3; // Favorisce il Sender
                    } else { // senderCount > recipientCount
                        nextIsRecipient = Math.random() < 0.7; // Favorisce il Recipient
                    }


                    if (nextIsRecipient && recipientIndex < shuffledRecipientBody.length) {
                        // Turno del Destinatario
                        script.push({ type: 'typing', delay: Math.floor(Math.random() * 1000) + 500 });
                        script.push({ type: 'message', sender: 'recipient', text: shuffledRecipientBody[recipientIndex], delay: Math.floor(Math.random() * 1500) + 1000 });
                        recipientIndex++;
                        recipientCount++;
                    } 
                    
                    else if (!nextIsRecipient && senderIndex < shuffledSender.length) {
                        // Turno del Mittente
                        const typingTime = shuffledSender[senderIndex].length * (Math.random() * 50 + 50); 
                        script.push({ type: 'sender_text_typing', text: shuffledSender[senderIndex], delay: Math.round(typingTime) });
                        script.push({ type: 'message', sender: 'sender', text: shuffledSender[senderIndex], delay: Math.floor(Math.random() * 500) + 200 });
                        senderIndex++;
                        senderCount++;
                    } 
                    
                    else {
                        // Se la persona "scelta" non ha più frasi, diamo la possibilità all'altra di finire il pool
                        if (senderIndex < shuffledSender.length) {
                            const typingTime = shuffledSender[senderIndex].length * (Math.random() * 50 + 50); 
                            script.push({ type: 'sender_text_typing', text: shuffledSender[senderIndex], delay: Math.round(typingTime) });
                            script.push({ type: 'message', sender: 'sender', text: shuffledSender[senderIndex], delay: Math.floor(Math.random() * 500) + 200 });
                            senderIndex++;
                            senderCount++;
                        } else if (recipientIndex < shuffledRecipientBody.length) {
                            script.push({ type: 'typing', delay: Math.floor(Math.random() * 1000) + 500 });
                            script.push({ type: 'message', sender: 'recipient', text: shuffledRecipientBody[recipientIndex], delay: Math.floor(Math.random() * 1500) + 1000 });
                            recipientIndex++;
                            recipientCount++;
                        } else {
                            break;
                        }
                    }
                }
                
                return script;
            }

            // Funzione per generare e garantire l'unicità degli script
            function generateUniqueScripts() {
                let script1;
                let script2;
                const MAX_ATTEMPTS = 10; // Evita loop infiniti in caso di sfortuna estrema

                let attempt1 = 0;
                do {
                    script1 = generateRandomScript();
                    attempt1++;
                } while (JSON.stringify(script1) === JSON.stringify(previousScript1) && attempt1 < MAX_ATTEMPTS);


                let attempt2 = 0;
                do {
                    script2 = generateRandomScript();
                    attempt2++;
                } while (
                    (JSON.stringify(script2) === JSON.stringify(previousScript2)) || 
                    (JSON.stringify(script2) === JSON.stringify(script1)) && 
                    attempt2 < MAX_ATTEMPTS
                );

                // Aggiorna la storia
                previousScript1 = script1;
                previousScript2 = script2;

                return { script1, script2 };
            }

            // =================================================================
            // === LOGICA PER UNA SINGOLA CHAT ===
            // =================================================================

            class ChatController {
                constructor(id, script) {
                    this.chatWindow = document.getElementById(`chat-window-${id}`);
                    this.typingIndicator = document.getElementById(`typing-indicator-${id}`); 
                    this.inputTypingText = document.getElementById(`input-typing-text-${id}`); 
                    this.inputMessageTypingContainer = document.getElementById(`input-message-typing-container-${id}`);
                    this.inputMessageTyping = document.getElementById(`input-message-typing-${id}`); 
                    this.script = script;
                    this.id = id;
                }

                addMessage(text, senderClass) {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message', senderClass);
                    messageElement.textContent = text;
                    this.chatWindow.insertBefore(messageElement, this.typingIndicator);
                    // RIMOZIONE: this.chatWindow.scrollTop = this.chatWindow.scrollHeight; 
                    
                    if (senderClass === 'recipient') {
                        receiveAudio.play().catch(e => console.log(`[Chat ${this.id}] Errore riproduzione audio ricezione:`, e));
                    }
                }

                showTyping() { 
                    this.typingIndicator.style.display = 'flex'; 
                    // RIMOZIONE: this.chatWindow.scrollTop = this.chatWindow.scrollHeight; 
                }
                hideTyping() { 
                    this.typingIndicator.style.display = 'none'; 
                }

                async typeSenderMessage(text, duration) {
                    this.inputTypingText.style.display = 'none';
                    this.inputMessageTypingContainer.style.display = 'flex'; 
                    this.inputMessageTyping.textContent = ''; 
                    
                    if (typingAudio.paused) {
                        typingAudio.play().catch(e => console.log(`[Chat ${this.id}] Errore riproduzione audio digitazione:`, e));
                    }
                    
                    const charDelay = duration / text.length; 
                    
                    for (let i = 0; i < text.length; i++) {
                        this.inputMessageTyping.textContent += text.charAt(i);
                        // RIMOZIONE: this.chatWindow.scrollTop = this.chatWindow.scrollHeight; 
                        await sleep(charDelay);
                    }
                    
                    typingAudio.pause();
                    typingAudio.currentTime = 0; 
                }

                resetInputBar() {
                    this.inputTypingText.style.display = 'block';
                    this.inputMessageTypingContainer.style.display = 'none';
                    this.inputMessageTyping.textContent = '';
                    
                    typingAudio.pause();
                    typingAudio.currentTime = 0;
                }

                async runScript() {
                    this.hideTyping();
                    this.resetInputBar();

                    for (const step of this.script) {
                        await sleep(step.delay);

                        if (step.type === 'message') {
                            this.hideTyping();
                            this.resetInputBar(); 
                            this.addMessage(step.text, step.sender);
                        } else if (step.type === 'typing') { 
                            this.showTyping();
                        } else if (step.type === 'sender_text_typing') { 
                            await this.typeSenderMessage(step.text, step.delay);
                        }
                    }

                    // Segnala che questa chat ha finito
                    if (this.id === 1) {
                        chat1Finished = true;
                    } else {
                        chat2Finished = true;
                    }

                    // Avvia il riavvio solo se entrambe le chat hanno finito
                    if (chat1Finished && chat2Finished) {
                        await startNewIteration();
                    }
                }
            }

            // =================================================================
            // === LOGICA DI AVVIO E RIPETIZIONE SINCRONIZZATA ===
            // =================================================================

            async function generateAndStartChats() {
                // Genera due script unici
                const { script1, script2 } = generateUniqueScripts();

                // Crea o aggiorna i controller
                if (!chat1) {
                    chat1 = new ChatController(1, script1);
                    chat2 = new ChatController(2, script2);
                } else {
                    chat1.script = script1;
                    chat2.script = script2;
                }

                // Resetta lo stato di completamento
                chat1Finished = false;
                chat2Finished = false;

                // Avvia le chat con un piccolo sfasamento temporale casuale
                chat1.runScript();
                sleep(Math.random() * 1000).then(() => chat2.runScript());
            }

            async function startNewIteration() {
                // PAUSA DI 15 SECONDI
                await sleep(15000); 

                // Pulisci entrambe le chat
                chat1.chatWindow.querySelectorAll('.message').forEach(msg => msg.remove());
                chat2.chatWindow.querySelectorAll('.message').forEach(msg => msg.remove());
                
                chat1.hideTyping();
                chat1.resetInputBar();
                chat2.hideTyping();
                chat2.resetInputBar();

                await sleep(500);
                
                // Riavvia con nuovi script unici
                await generateAndStartChats();
            }

            // AVVIO INIZIALE
            generateAndStartChats();

        });
    </script>

</body>
</html>
